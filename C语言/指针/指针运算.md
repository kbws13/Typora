# 指针运算
给一个指针加1表示要让指针指向下一个变量

```cpp
inta[10];
int *p=a;
*(p+1)-->a[1];
```
如果指针不是指向一片连续分配的空间，如数组，则这种运算没有任何意义

# 指针计算
这些算数运算可以对指针做：

给指针加、减一个整数（+，+=，-，-=）

递增递减（++、--）

两个指针相减（两个指针相减结果为两个地址之间有多少个元素）

---
# \*p++
取出p所指的那个数据来，完事之后顺便把p挪到下一个位置去

\*的优先级虽然高但是没有++高

刚用于数组类的连续空间操作

在某些CPU上，这可以之间被翻译成一条汇编指令

```cpp
//遍历数组
int main(){
        char a[10]={0,1,2,3,4,5,6,7,8,9,-1};
        char *p=&ac[0];
        for(p=ac;*p!=-1;){
            printf("%d\n",*p++);
        }
}
```
# 指针比较
<,<=,==,>,>=,!=都可以对指针做

比较他们在内存中的地址

数组中的单元的地址肯定是线性递增的

# 0地址
当然你的内存中有0地址，但0地址通常是一个不能随便碰的地址

所以你的指针不应该具有0值

因此可以用0地址表示特殊的事情：

返回的指针无效

指针没有被真正初始化（先初始化为0）

NULL是一个预定意义的符号，表示0地址

有的编译器不愿意你用0来表示0地址

# 指针的类型
无论指向什么类型，所有的指针的大小都一样，因为都是地址

但是指向不同类型的指针是不能直接相互赋值的

这是为了避免用错指针

# 指针的类型转换
void\*表示不知道指向什么东西的指针

计算时与char\*相同（但不相通）

指针也可以转换类型

```cpp
int *p=&i;
void *q=(void*)p;
```
这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量

我不在当你是int了，我认为就是个void！

# 用指针做什么
1、需要传入较大的数据时作参数

2、传入数组后对数组做操作

3、函数返回不止一个结果

需要用函数来修改不止一个变量

4、动态申请的内存