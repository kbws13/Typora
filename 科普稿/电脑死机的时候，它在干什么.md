# 电脑为什么会死机？

​    相信每一个有电脑的人几乎都经历过电脑死机。打着游戏好好的电脑突然蓝屏，真的是一件很令人崩溃的事。学了计算机后，我就时常在想电脑为什么会死机？

​     众所周知，计算机的核心中枢是中央控制处理器CPU。在计算机基础课程上学过：CPU是一个“死脑筋”，只知道不断地取出指令逐个执行，直到电脑关机。所以死机分为以下两种，一种是CPU不工作了，不再执行下一条指令了，这属于硬件死机，这种情况基本不会发生。通常情况下，都是软件层面的崩溃。也就是说，中央处理器被卡在某个地方出不来了。结果，应该执行的程序无法执行。看起来就是死机了一般。

​     你可能在想，要是写一个死循环，让CPU一直运行程序，电脑是不是就死机了？比如这样：

     ```
     Void dead_loop（） {
     	while （1） {
     		...
     	}
     }
     ```

​     当你运行这段代码的时候，会发现CPU的散热风扇可能会转起来，但计算机依旧能正常进行工作，并没有出现死机。死循环，CPU不应该是一直运行这段代码吗？为什么不会死机？

​     这就要提到一个概念：中断。

​     中断

​     中断这个一个东西，绝对是计算机发展史上最伟大的发明之一。中断，顾名思义，是用来中断 CPU 的正常工作，以便让它去处理其他的指令程序。

​     操作系统之所以能总管一切，得益于它启动时给CPU安插的一系列的中断函数，好让操作系统能周期性地收回CPU的执行权，调用别的线程来执行。因此，即使某个线程进入死循环，在其时间片用完后，会被强制退出CPU，让另一个程序执行。所以想用一个死循环就导致电脑死机是不可能的。

​     退一万步讲，就算不考虑中断，现在的CPU大都是多核，一个线程进入死循环，但还有别的核可以参与管理系统进行调度，也依然不会出现死机。

​     那么回到开始的问题，到底CPU因为什么原因，连中断也不能阻止它呢？

​     其实有两种情况：

​     1、中断确实拿它没办法。

​     其实，中断也是有优先级的。

​     这很容易理解，例如， CPU 正在执行一个程序，突然发生一个中断事件。CPU保存好当前执行的上下文，转头去处理这个系统中断事件，但刚处理到一半儿，这时我们又有一个新的中断事件问题来了，那CPU怎么办？要不要响应？因此中断也具有优先级，低优先级的中断不能打断高优先级的中断。

​     有了这个重要前提，如果操作系统内核代码写得不恰当，在处理某个中断的时候陷入了一个死循环，比如自旋锁，会发生什么？

由于 CPU 在处理中断时处于高优先级运行状态，从而导致 CPU 不受普通中断的影响，也就是死机。

​     2、中断能抢到CPU，但没有线程可以调用。

​     程序员应该很熟悉死锁的概念。两个线程A等待B，B等待A，两个线程等待对方放弃（释放锁）。如果死锁发生在进行应用层面，那问题不大，最多就是两个程序死了。但如果发生在内核呢？在 Windows 操作系统内核中，有许多全局锁，其中一个偶然导致死锁，其他所需的线程必须进入等待队列，这就会导致死机。

![metapro添加图片](%E7%94%B5%E8%84%91%E6%AD%BB%E6%9C%BA%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%AE%83%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88.assets/clip_image002.jpg)

 

引用一段另一位大神Tim Chen的描述（我觉得特别形象）：

![metapro添加图片](%E7%94%B5%E8%84%91%E6%AD%BB%E6%9C%BA%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%AE%83%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88.assets/clip_image004.jpg)

 